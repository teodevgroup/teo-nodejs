/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export function serveStaticFiles(base: string, path: string): Response
export class HandlerGroup {
  defineHandler(name: string, callback: (ctx: RequestCtx) => Response | Promise<Response>): void
}
export class Model {
  setData(key: string, value: unknown): void
  data(key: string): unknown
}
export class Field {
  setData(key: string, value: unknown): void
  data(key: string): unknown
}
export class Property {
  setData(key: string, value: unknown): void
  data(key: string): unknown
}
export class Relation {
  setData(key: string, value: unknown): void
  data(key: string): unknown
}
export class Namespace {
  isMain(): boolean
  isStd(): boolean
  path(): Array<string>
  namespace(name: string): Namespace | null
  namespaceOrCreate(name: string): Namespace
  namespaceAtPath(path: Array<string>): Namespace | null
  namespaceOrCreateAtPath(path: Array<string>): Namespace
  defineModelDecorator(name: string, body: (args: {[key: string]: any}, model: Model) => void): void
  defineModelFieldDecorator(name: string, body: (args: {[key: string]: any}, field: Field) => void): void
  defineModelRelationDecorator(name: string, body: (args: {[key: string]: any}, relation: Relation) => void): void
  defineModelPropertyDecorator(name: string, body: (args: {[key: string]: any}, property: Property) => void): void
  defineEnumDecorator(name: string, body: (args: {[key: string]: any}, e: Enum) => void): void
  defineEnumMemberDecorator(name: string, body: (args: {[key: string]: any}, member: EnumMember) => void): void
  definePipelineItem(name: string, body: (input: any, args: {[key: string]: any}, object: any, teo: any) => any | Promise<any>): void
  defineTransformPipelineItem(name: string, callback: (input: any, args: {[key: string]: any}, object: any, teo: any) => any | Promise<any>): void
  defineValidatorPipelineItem(name: string, callback: (input: any, args: {[key: string]: any}, object: any, teo: any) => boolean | string | undefined | null | Promise<boolean | string | undefined | null>): void
  /** Register a named callback. */
  defineCallbackPipelineItem(name: string, callback: (input: any, args: {[key: string]: any}, object: any, teo: any) => void | Promise<void>): void
  defineComparePipelineItem<T>(name: string, callback: (oldValue: T, newValue: T, args: {[key: string]: any}, object: any, teo: any) => boolean | string | undefined | null | Promise<boolean | string | undefined | null>): void
  defineHandler(name: string, callback: (ctx: RequestCtx) => Response | Promise<Response>): void
  defineHandlerGroup(name: string, callback: (group: HandlerGroup) => void): void
  defineModelHandlerGroup(name: string, callback: (group: HandlerGroup) => void): void
  defineMiddleware(name: string, callback: (args: {[key: string]: any}) => (ctx: RequestCtx, next: (ctx: RequestCtx) => Promise<Response>) => Promise<Response> | Response): void
}
export class DateOnly {
  toString(): string
  static fromString(string: string): unknown
}
export class ObjectId {
  toString(): string
  static fromString(string: string): unknown
}
/**
 * File
 * File only represent input file in form request.
 */
export class File {
  filepath: string
  contentType?: string
  filename: string
  filenameExt?: string
}
export class Range {
  upperbond(): number
  lowerbond(): number
  isClosed(): boolean
  isOpen(): boolean
}
export class EnumVariant {
  toString(): string
  static fromString(value: string): EnumVariant
}
export class OptionVariant { }
export class Pipeline { }
export class InterfaceEnumVariant { }
export class App {
  /** Create a Teo app. */
  constructor()
  /** @internal */
  static withCli(cli: boolean): App
  /** @internal */
  _prepare(): Promise<void>
  /** @internal */
  _run(): Promise<void>
  /** Run this app. */
  run(): Promise<void>
  /** Run before server is started. */
  setup(callback: (ctx: any) => void | Promise<void>): void
  /** Define a custom program. */
  program(name: string, callback: (ctx: any) => void | Promise<void>): void
  mainNamespace(): Namespace
}
export class ReadOnlyHeaderMap {
  keys(): Array<string>
  len(): number
  containsKey(key: string): boolean
  get(key: string): string | null
}
export class RequestCtx {
  request(): Request
  body(): any
  teo(): any
  handlerMatch(): HandlerMatch
  pathArguments(): any
}
export class HandlerMatch {
  path(): Array<string>
  handlerName(): string
  captures(): object
}
export class Request {
  method(): string
  path(): string
  queryString(): string
  contentType(): string
  headers(): ReadOnlyHeaderMap
}
export class ReadWriteHeaderMap {
  keys(): Array<string>
  len(): number
  containsKey(key: string): boolean
  get(key: string): string | null
  set(key: string, value: string): void
}
export class Response {
  static empty(): Response
  static string(content: string, contentType: string): Response
  static teon(value: unknown): Response
  static html(content: string): Response
  static data(value: unknown): Response
  static dataMeta(data: unknown, meta: unknown): Response
  static file(path: string): Response
  static redirect(path: string): Response
  setCode(code: number): void
  code(): number
  headers(): ReadWriteHeaderMap
  isFile(): boolean
  isText(): boolean
  isEmpty(): boolean
  isTeon(): boolean
  getText(): string | null
  getTeon(): unknown
  getFile(): string | null
}
export class EnumMember {
  setData(key: string, value: unknown): void
  data(key: string): unknown
}
export class Enum {
  setData(key: string, value: unknown): void
  data(key: string): unknown
}
export class TeoError extends Error {
  constructor(message: string, code: number = 500, errors: { [key: string]: string } | null = null)
  public get code(): number
  public get errorMessage(): string
  public get errors(): { [key: string]: string } | null
  public messagePrefixed(prefix: string): TeoError
  public pathPrefixed(prefix: string): TeoError
  public mapPath(mapper: (string) => string): TeoError
  static public notFound(message: string = "not found"): TeoError
  static public invalidRequest(message: string = "value is invalid"): TeoError
  static public internalServerError(message: string = "internal server error"): TeoError
  static public unauthorized(message: string = "unauthorized"): TeoError  
}
